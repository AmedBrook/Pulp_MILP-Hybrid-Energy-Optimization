{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HEO. \u00b6 HEO is a PuLP-MILP based Hybrid Energy Optimizer, for oil and fuel optimization with battery storage system integration. Project description and context \u00b6 The project aims to explore the possibility of integrating energy storage facilities within the shipping industry market. In this application we simulate one possible solution on how to synchronize fuel based gensets with a battery storage system alongside with energy optimization to reduce energy cost throughout the trip journey. The whole project is build based on an optimization mathematical model and uses MILP (mixed integer linear programming) methods to solve optimally the problem. In the Notebook scripts associated with this project, we simulate an application used to optimize fuel consumption for vessels using one genset to produce the required energy and one battery storage system to store and realise the excess of that energy when needed in a hybrid mode. The farmwork used in this case study is PuLP, to solve a Mixed Integer Linear Programming problem together with first the built-in solver CBC and then with a commercial solver, we used Gurobi in our case. Project use case \u00b6 This particular case is initially specific for the offshore shipping industry as they are the most transportation fuel consuming and needing some sort of solutions to use fuel optimally in their trips. However, this is not only exclusive to this sector, it can be easily extended to other sectors as long as the purpose is to optimize energy usage and energy hybridization. Project setup options \u00b6 Standalone setup \u00b6 Environment. \u00b6 Create a new environment aside of the root, and name it somthing recognisable, we gave it a name here as HEO_model, we have used here python version 3.9.7. To do so, run the command : $ conda create --HEO_model python=3.9.7 Requirements and Dependencies. \u00b6 Before stating the setup process you need to have setuptools installed, if you don't have it already do through the following commands: Python package index (Pypi) : $ pip install setuptools Anaconda package index (Conda) : $ conda install -c conda-forge setuptools Now that you have setuptools in you environment, in order to install all packages and dependencies at once run the command : $ python -m pip install -e . Pre-configured setup \u00b6 While the manual installation can walk you through around the various commands basics for each used packages in the project, chances are you might already know those commands and you don't want to bother yourself about taping every single command, so that's why we have provided the possibility to use make scripting, to make life easy for you. You find in the following the commands you will need to do this. In case you have make installed in your system, for Linux based system it comes already installed in your system you don't need to install anything just skeep this part to {...}. For windows based systems there are multiple ways to get GNU make installed, like for example Cygwin, Nmake, Cmake..., however we recommand to go for chocolatey , we think it's the most straighforward way to install make for windows systems with less effort. chocolatey \u00b6 First thing first, we will install chocolatey, make sure you are using the Powershell command as an admin, Then run this command first : Get-ExecutionPolicy If it returns Restricted, then run : Set-ExecutionPolicy AllSigned or Set-ExecutionPolicy Bypass -Scope Process Now, to install chocolatey run the following command by coping it at once and past it in command line, then hit enter: Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) Please check chocolatey website for more guidance ! Make \u00b6 Now that you have chocolatey installed, we can install make by running the command : $ choco install make --version=3.81 Once make installation is done, and assuming that you have downloaded the project files in your local machine it's very easy to workout everything. To create the conda environment run the command : $ make create_env To setup the project run the command : $ make setup Mkdocs \u00b6 We are using Mkdocs in order to generate documentation pages for the project. to install Mkdocs, run the command : $ pip install mkdocs To create a new project with the name \u00b4heo\u00b4, you can run: $ mkdocs new heo After creation the project, you might have something simmilar to this: mkdocs.yml docs |___ index.md |___./... if you want to preview live the changes you make on the mkdocs pages, then you can serve them by running the command: $ python mkdocs serve Mathjax \u00b6 Mathjax is a Javascript library that can display mathimatical notations in the browser using LaTex or other. In order to integarate Mathjax within Mkdocs do the following: Install pymdown-extensions (Pypi): $ python -m pip install pymdown-extensions Within your mkdocs folder create the following: mkdocs_______ |___ docs |___ javascripts | |___ mathjax.js | Add the following script lines in the configuration file mkdocs.yml : extra_javascript: javascripts/mathjax.js https://polyfill.io/v3/polyfill.min.js?features=es6 https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js Testing units \u00b6 Testing the environment \u00b6 To test packages and dependencies just run the command : $ make env_test Behind the scenes, make will go over the Makefile located in our directory which itself will chain to all test units located in /src/tests directory and execute every single test module existing in that directory. Testing syntax & style \u00b6 To lint code scripts we are using flake8, just run the following command : $ make lint Under the hood, make will go over the Makefile located in our directory which itself will chain to all coding resources in /src/functions and /notebooks directories and will check the syntax and style of your code using flake8 to meet PEP8 standards. Testing internal modules \u00b6 In our code we ended up using three main functions which help us to implemente the problem, the first function is called FuelCon it is used to calculate based on a linear model the fuel comsumption of the genset for a specific power load P . The second function is called lwd , is the abreviation of load window, which is used to constructe a load profile for a specific number of time steps out of a given sets of power loads arrays. The third one is called lixtr and it's the abreviation of list extraction, which could be used in the section 'Pre-processing visualization data' for extracting lists out of dictionaries. So in order to make sure those functions are behaving as is should be some testing routings are required by following the next commands. To test the FuelCon function, run the command: $ make fuelCon_test To test the lwd function, run the command: $ make lwd_test To test the lixtr functions, run the command: $ make lixtr_test","title":"Project context"},{"location":"#heo","text":"HEO is a PuLP-MILP based Hybrid Energy Optimizer, for oil and fuel optimization with battery storage system integration.","title":"HEO."},{"location":"#project-description-and-context","text":"The project aims to explore the possibility of integrating energy storage facilities within the shipping industry market. In this application we simulate one possible solution on how to synchronize fuel based gensets with a battery storage system alongside with energy optimization to reduce energy cost throughout the trip journey. The whole project is build based on an optimization mathematical model and uses MILP (mixed integer linear programming) methods to solve optimally the problem. In the Notebook scripts associated with this project, we simulate an application used to optimize fuel consumption for vessels using one genset to produce the required energy and one battery storage system to store and realise the excess of that energy when needed in a hybrid mode. The farmwork used in this case study is PuLP, to solve a Mixed Integer Linear Programming problem together with first the built-in solver CBC and then with a commercial solver, we used Gurobi in our case.","title":"Project description and context"},{"location":"#project-use-case","text":"This particular case is initially specific for the offshore shipping industry as they are the most transportation fuel consuming and needing some sort of solutions to use fuel optimally in their trips. However, this is not only exclusive to this sector, it can be easily extended to other sectors as long as the purpose is to optimize energy usage and energy hybridization.","title":"Project use case"},{"location":"#project-setup-options","text":"","title":"Project setup options"},{"location":"#standalone-setup","text":"","title":"Standalone setup"},{"location":"#environment","text":"Create a new environment aside of the root, and name it somthing recognisable, we gave it a name here as HEO_model, we have used here python version 3.9.7. To do so, run the command : $ conda create --HEO_model python=3.9.7","title":"Environment."},{"location":"#requirements-and-dependencies","text":"Before stating the setup process you need to have setuptools installed, if you don't have it already do through the following commands: Python package index (Pypi) : $ pip install setuptools Anaconda package index (Conda) : $ conda install -c conda-forge setuptools Now that you have setuptools in you environment, in order to install all packages and dependencies at once run the command : $ python -m pip install -e .","title":"Requirements and Dependencies."},{"location":"#pre-configured-setup","text":"While the manual installation can walk you through around the various commands basics for each used packages in the project, chances are you might already know those commands and you don't want to bother yourself about taping every single command, so that's why we have provided the possibility to use make scripting, to make life easy for you. You find in the following the commands you will need to do this. In case you have make installed in your system, for Linux based system it comes already installed in your system you don't need to install anything just skeep this part to {...}. For windows based systems there are multiple ways to get GNU make installed, like for example Cygwin, Nmake, Cmake..., however we recommand to go for chocolatey , we think it's the most straighforward way to install make for windows systems with less effort.","title":"Pre-configured setup"},{"location":"#chocolatey","text":"First thing first, we will install chocolatey, make sure you are using the Powershell command as an admin, Then run this command first : Get-ExecutionPolicy If it returns Restricted, then run : Set-ExecutionPolicy AllSigned or Set-ExecutionPolicy Bypass -Scope Process Now, to install chocolatey run the following command by coping it at once and past it in command line, then hit enter: Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) Please check chocolatey website for more guidance !","title":"chocolatey"},{"location":"#make","text":"Now that you have chocolatey installed, we can install make by running the command : $ choco install make --version=3.81 Once make installation is done, and assuming that you have downloaded the project files in your local machine it's very easy to workout everything. To create the conda environment run the command : $ make create_env To setup the project run the command : $ make setup","title":"Make"},{"location":"#mkdocs","text":"We are using Mkdocs in order to generate documentation pages for the project. to install Mkdocs, run the command : $ pip install mkdocs To create a new project with the name \u00b4heo\u00b4, you can run: $ mkdocs new heo After creation the project, you might have something simmilar to this: mkdocs.yml docs |___ index.md |___./... if you want to preview live the changes you make on the mkdocs pages, then you can serve them by running the command: $ python mkdocs serve","title":"Mkdocs"},{"location":"#mathjax","text":"Mathjax is a Javascript library that can display mathimatical notations in the browser using LaTex or other. In order to integarate Mathjax within Mkdocs do the following: Install pymdown-extensions (Pypi): $ python -m pip install pymdown-extensions Within your mkdocs folder create the following: mkdocs_______ |___ docs |___ javascripts | |___ mathjax.js | Add the following script lines in the configuration file mkdocs.yml : extra_javascript: javascripts/mathjax.js https://polyfill.io/v3/polyfill.min.js?features=es6 https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js","title":"Mathjax"},{"location":"#testing-units","text":"","title":"Testing units"},{"location":"#testing-the-environment","text":"To test packages and dependencies just run the command : $ make env_test Behind the scenes, make will go over the Makefile located in our directory which itself will chain to all test units located in /src/tests directory and execute every single test module existing in that directory.","title":"Testing the environment"},{"location":"#testing-syntax-style","text":"To lint code scripts we are using flake8, just run the following command : $ make lint Under the hood, make will go over the Makefile located in our directory which itself will chain to all coding resources in /src/functions and /notebooks directories and will check the syntax and style of your code using flake8 to meet PEP8 standards.","title":"Testing syntax &amp; style"},{"location":"#testing-internal-modules","text":"In our code we ended up using three main functions which help us to implemente the problem, the first function is called FuelCon it is used to calculate based on a linear model the fuel comsumption of the genset for a specific power load P . The second function is called lwd , is the abreviation of load window, which is used to constructe a load profile for a specific number of time steps out of a given sets of power loads arrays. The third one is called lixtr and it's the abreviation of list extraction, which could be used in the section 'Pre-processing visualization data' for extracting lists out of dictionaries. So in order to make sure those functions are behaving as is should be some testing routings are required by following the next commands. To test the FuelCon function, run the command: $ make fuelCon_test To test the lwd function, run the command: $ make lwd_test To test the lixtr functions, run the command: $ make lixtr_test","title":"Testing internal modules"},{"location":"Project_overview/","text":"Project overview. \u00b6 HEO Model - Genset(s) and Baterie(s) \u00b6 The solution introduced in this project aims to utilize a genset optimally by integrating an energy storage in the form of set batteries to let ship genset run at optimal load over a predefined time horizon. The primary example is built around an offshore shipping example, but the general framework of the studied solution can be extrapolated to any specific setting where there are two or more energy sources. Model synopsys \u00b6 The model developed is of Mixed Integer Linear Programming (MILP) type. All functions (objective and constraints) are linear, and the variables can be continuous, integer or binary. Binary variables are used to model logical decisions in the problem (i.e. a generator is used = 1 or not used =o). The optimal solution to the MILP problem is found by solving a sequence of many LP problems (simpler problems that are solved very fast), where the number of LP problems to solve depends on the number of binary and integer variables (more variables give a larger combinatorial solution space). Nonlinear functions can in many cases be approximated with piecewise linear ones, meaning that the MILP approach is quite general. Regardless of state-of-the-art of MILP solvers on the market that are highly efficient and capable of solving even very \"large\" MILP problems. Model optimization policy \u00b6 The optimization model is done in discrete time, i.e. the time horizon is divided into smaller time steps and in each time step everything is kept constant. The objective is to minimize fuel consumption within the time horizon given through a pre-defined load schedule for each time step. Logical variables are introduced to facilitate the logic needed for operating the genset(s) and batterie(s). The model is a proof of concept and relatively easy to adjust and scale up for potential use cases.","title":"Project overview"},{"location":"Project_overview/#project-overview","text":"","title":"Project overview."},{"location":"Project_overview/#heo-model-gensets-and-bateries","text":"The solution introduced in this project aims to utilize a genset optimally by integrating an energy storage in the form of set batteries to let ship genset run at optimal load over a predefined time horizon. The primary example is built around an offshore shipping example, but the general framework of the studied solution can be extrapolated to any specific setting where there are two or more energy sources.","title":"HEO Model - Genset(s) and Baterie(s)"},{"location":"Project_overview/#model-synopsys","text":"The model developed is of Mixed Integer Linear Programming (MILP) type. All functions (objective and constraints) are linear, and the variables can be continuous, integer or binary. Binary variables are used to model logical decisions in the problem (i.e. a generator is used = 1 or not used =o). The optimal solution to the MILP problem is found by solving a sequence of many LP problems (simpler problems that are solved very fast), where the number of LP problems to solve depends on the number of binary and integer variables (more variables give a larger combinatorial solution space). Nonlinear functions can in many cases be approximated with piecewise linear ones, meaning that the MILP approach is quite general. Regardless of state-of-the-art of MILP solvers on the market that are highly efficient and capable of solving even very \"large\" MILP problems.","title":"Model synopsys"},{"location":"Project_overview/#model-optimization-policy","text":"The optimization model is done in discrete time, i.e. the time horizon is divided into smaller time steps and in each time step everything is kept constant. The objective is to minimize fuel consumption within the time horizon given through a pre-defined load schedule for each time step. Logical variables are introduced to facilitate the logic needed for operating the genset(s) and batterie(s). The model is a proof of concept and relatively easy to adjust and scale up for potential use cases.","title":"Model optimization policy"},{"location":"authors/","text":"Intelligent Systems Institute, Novia UAS \u00b6 Authors: Ahmed Mabrouk , CEng., R&D Project Assistant, Novia Acknowledgement: Johan West\u00f6 , D.Sc. (Tech.), R&D Project Leader, Novia Ray P\u00f6rn , Ph.D., Principal Lecturer, Novia Websites : Intelligent Systems Institute of Novia. Novia University of Applied Sciences.","title":"Authors"},{"location":"authors/#intelligent-systems-institute-novia-uas","text":"Authors: Ahmed Mabrouk , CEng., R&D Project Assistant, Novia Acknowledgement: Johan West\u00f6 , D.Sc. (Tech.), R&D Project Leader, Novia Ray P\u00f6rn , Ph.D., Principal Lecturer, Novia Websites : Intelligent Systems Institute of Novia. Novia University of Applied Sciences.","title":"Intelligent Systems Institute, Novia UAS"},{"location":"chng_log/","text":"Releases. \u00b6 Version 0.2.1. [Release] \u00b6 Date: 31.5.2023. Version 0.2.0. [Pre-release] \u00b6 Date: 27.11.2022. Version 0.1.5. [Pre-release] \u00b6 Date: 29.10.2022. Version 0.1.4. [Pre-release] \u00b6 Date: 18.09.2022. \\(\\newline\\) \\(\\newline\\) \\(\\newline\\)","title":"Releases"},{"location":"chng_log/#releases","text":"","title":"Releases."},{"location":"chng_log/#version-021-release","text":"Date: 31.5.2023.","title":"Version 0.2.1. [Release]"},{"location":"chng_log/#version-020-pre-release","text":"Date: 27.11.2022.","title":"Version 0.2.0. [Pre-release]"},{"location":"chng_log/#version-015-pre-release","text":"Date: 29.10.2022.","title":"Version 0.1.5. [Pre-release]"},{"location":"chng_log/#version-014-pre-release","text":"Date: 18.09.2022. \\(\\newline\\) \\(\\newline\\) \\(\\newline\\)","title":"Version 0.1.4. [Pre-release]"},{"location":"contr_guide/","text":"How to contribute to HEO model. \u00b6 This is a guide on how to contribute to HEO project. Contribution steps \u00b6 Fork the repo. Clone your forked repo. Install dependencies. Make your changes. Create a test for your changes if needed. Make sure all the tests pass. Lint the code. Ensure the docs are accurate. Submit a Pull Request. On top of having python installed, we will be using git and the command line. Also, we assume you have a github account and know how to fork a project. We will use plain git through the command line but feel free to use the git client of your choice. Forking the project \u00b6 You can follow the github guides to fork a project: here and also here . You need a github account to fork a github project. It\u2019s free. Cloning the project \u00b6 You first need to download the HEO project from your fork. In the following command replace usrn with your actual username: $ git clone git@github.com:usrn/Pulp_MILP-Hybrid-Energy-Optimization.git That\u2019s it, you will download the whole project. Running tests \u00b6 To run the project tests you need to execute the Makefile rules: $ cd Pulp_MILP-Hybrid-Energy-Optimization/Makefile $ make It will test your python environment, PuLP packages, internal modules as well as installing the required external dependancies if they are not already installed. Creating a test file \u00b6 When you fix an issue in HEO model or add a functionality, you should add a test to the repository. For this you should do the following: Go to src/functions/ folder and add a new method. Go to src/functions/tests folder and add an other method that tests your changes. linting the code \u00b6 After writing the code nedded for the contribution you have to check for style and syntax errors, for this we use flake8, you just run the command in root directory : $ make lint Building the documentation \u00b6 The documentation is based on Mkdocs and MathJax. To build the documentation see the Readme file (Sections Mkdocs and Mathjax). Making a Pull Request \u00b6 When you\u2019re done with the changes in your machine and you\u2019re satisfied with the result you have, you can commit it, push it to github and then create a PR. The first two are easy: $ git status # this shows what's changed $ git add some_modified_file.py # do this for all changes you want to write $ git commit -m \"some message\" # include a meaningful message $ git push main","title":"Contributor guide"},{"location":"contr_guide/#how-to-contribute-to-heo-model","text":"This is a guide on how to contribute to HEO project.","title":"How to contribute to HEO model."},{"location":"contr_guide/#contribution-steps","text":"Fork the repo. Clone your forked repo. Install dependencies. Make your changes. Create a test for your changes if needed. Make sure all the tests pass. Lint the code. Ensure the docs are accurate. Submit a Pull Request. On top of having python installed, we will be using git and the command line. Also, we assume you have a github account and know how to fork a project. We will use plain git through the command line but feel free to use the git client of your choice.","title":"Contribution steps"},{"location":"contr_guide/#forking-the-project","text":"You can follow the github guides to fork a project: here and also here . You need a github account to fork a github project. It\u2019s free.","title":"Forking the project"},{"location":"contr_guide/#cloning-the-project","text":"You first need to download the HEO project from your fork. In the following command replace usrn with your actual username: $ git clone git@github.com:usrn/Pulp_MILP-Hybrid-Energy-Optimization.git That\u2019s it, you will download the whole project.","title":"Cloning the project"},{"location":"contr_guide/#running-tests","text":"To run the project tests you need to execute the Makefile rules: $ cd Pulp_MILP-Hybrid-Energy-Optimization/Makefile $ make It will test your python environment, PuLP packages, internal modules as well as installing the required external dependancies if they are not already installed.","title":"Running tests"},{"location":"contr_guide/#creating-a-test-file","text":"When you fix an issue in HEO model or add a functionality, you should add a test to the repository. For this you should do the following: Go to src/functions/ folder and add a new method. Go to src/functions/tests folder and add an other method that tests your changes.","title":"Creating a test file"},{"location":"contr_guide/#linting-the-code","text":"After writing the code nedded for the contribution you have to check for style and syntax errors, for this we use flake8, you just run the command in root directory : $ make lint","title":"linting the code"},{"location":"contr_guide/#building-the-documentation","text":"The documentation is based on Mkdocs and MathJax. To build the documentation see the Readme file (Sections Mkdocs and Mathjax).","title":"Building the documentation"},{"location":"contr_guide/#making-a-pull-request","text":"When you\u2019re done with the changes in your machine and you\u2019re satisfied with the result you have, you can commit it, push it to github and then create a PR. The first two are easy: $ git status # this shows what's changed $ git add some_modified_file.py # do this for all changes you want to write $ git commit -m \"some message\" # include a meaningful message $ git push main","title":"Making a Pull Request"},{"location":"low_up_bnds/","text":"Variables bounds. \u00b6 Linear programing variables are the variables whose values the optimizer will solve for in each time step, those variables are bounded from both sides (lower and upper) to finite the problem region of values and hence lowering the complexity to solve it. Upper and lower bounds \u00b6 LPvariable Lower bound Upper bound \\(Q_k^{\\mathrm{bat}}\\) \\(0\\ldotp 2.Q_{\\mathrm{max}}\\) \\(Q_{\\mathrm{max}}\\) \\(P_{k}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{load}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{to\\_bat}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{from\\_bat}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(Y_k\\) 0 1 \\(Y_k^{\\mathrm{to\\_bat}}\\) 0 1 \\(Y_k^{\\mathrm{from\\_bat}}\\) 0 1 \\(Z\\) 0 1 \\(FOC\\) 0 \\(FOC_{max}\\)","title":"Upper and lower bounds"},{"location":"low_up_bnds/#variables-bounds","text":"Linear programing variables are the variables whose values the optimizer will solve for in each time step, those variables are bounded from both sides (lower and upper) to finite the problem region of values and hence lowering the complexity to solve it.","title":"Variables bounds."},{"location":"low_up_bnds/#upper-and-lower-bounds","text":"LPvariable Lower bound Upper bound \\(Q_k^{\\mathrm{bat}}\\) \\(0\\ldotp 2.Q_{\\mathrm{max}}\\) \\(Q_{\\mathrm{max}}\\) \\(P_{k}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{load}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{to\\_bat}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(P_k^{\\mathrm{from\\_bat}}\\) \\(P_{\\mathrm{min}}\\) \\(0.9.P_{\\mathrm{max}}\\) \\(Y_k\\) 0 1 \\(Y_k^{\\mathrm{to\\_bat}}\\) 0 1 \\(Y_k^{\\mathrm{from\\_bat}}\\) 0 1 \\(Z\\) 0 1 \\(FOC\\) 0 \\(FOC_{max}\\)","title":"Upper and lower bounds"},{"location":"lp_cstrs/","text":"Problem LP constraints. \u00b6 Linear programming constraints \u00b6 Linear programming constraints (LP constraints) are the rules that gouverne the problem optimization process. They are fondamentally set of equations, they might be either inequality equations ( example : \\({a} + {b} \\le {c}\\,\\) ) or equality equations ( example : \\({a} + {b} = {c}\\,q\\) ) constructed based on the LP variables quantities and problem parameters. (See. Problem LP variables and Problem LP constraints). Set of problem LP constraints \u00b6 Load requirements : \\[\\begin{flalign*} \\color{black} & L_k =P_k^{\\mathrm{load}} +\\eta {\\;}^{\\mathrm{from\\_Bat}} {\\cdot \\;P}_k^{\\mathrm{from\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Power split : \\[\\begin{flalign*} & P_{k\\;} =P_k^{\\mathrm{load}} {+\\;P}_k^{\\mathrm{to\\_Bat}}\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Charge balance constraints : \\[\\begin{flalign*} & Q_k =Q_{k-1} +\\eta^{\\mathrm{to\\_Bat}} \\cdot \\;P_k^{\\mathrm{to\\_Bat}} \\Delta t-\\;P_k^{\\mathrm{from\\_Bat}} \\Delta t\\\\ & Q_0 =Q_{\\mathrm{init}}\\\\ & Q_n =Q_{\\mathrm{final}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Genset constraints : \\[\\begin{flalign*} & P_{k\\;} \\le {0\\ldotp 9P}_{\\mathrm{max}\\;} {\\cdot y}_k & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n\\\\ & P_{k\\;} \\le {0\\ldotp 2P}_{\\mathrm{max}\\;} {\\cdot y}_k\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Battery logical constraints : \\[\\begin{flalign*} & y_k^{\\mathrm{to\\_Bat}} +y_{k\\;}^{\\mathrm{from\\_Bat}} \\le 1 & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n\\\\ & P_k^{\\mathrm{to\\_Bat}} \\le 0\\ldotp 9P_{\\mathrm{max}} {\\cdot y}_k^{\\mathrm{to\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\\\ & P_k^{\\mathrm{from\\_Bat}} \\le 0\\ldotp 9P_{\\mathrm{max}} {\\cdot \\;y}_k^{\\mathrm{from\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Fuel consumption : \\[\\begin{flalign*} & {FC}_{k\\;} ={aP}_{k\\;} +b-{fc}_{offset} \\cdot \\left(1-y_k \\right)\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Objective linearization : \\[\\begin{flalign*} & z_k \\ge y_k -y_{k-1} & \\forall\\,\\,\\,\\,\\,\\, k=2,\\dots ,n \\end{flalign*}\\]","title":"Problem constraints"},{"location":"lp_cstrs/#problem-lp-constraints","text":"","title":"Problem LP constraints."},{"location":"lp_cstrs/#linear-programming-constraints","text":"Linear programming constraints (LP constraints) are the rules that gouverne the problem optimization process. They are fondamentally set of equations, they might be either inequality equations ( example : \\({a} + {b} \\le {c}\\,\\) ) or equality equations ( example : \\({a} + {b} = {c}\\,q\\) ) constructed based on the LP variables quantities and problem parameters. (See. Problem LP variables and Problem LP constraints).","title":"Linear programming constraints"},{"location":"lp_cstrs/#set-of-problem-lp-constraints","text":"Load requirements : \\[\\begin{flalign*} \\color{black} & L_k =P_k^{\\mathrm{load}} +\\eta {\\;}^{\\mathrm{from\\_Bat}} {\\cdot \\;P}_k^{\\mathrm{from\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Power split : \\[\\begin{flalign*} & P_{k\\;} =P_k^{\\mathrm{load}} {+\\;P}_k^{\\mathrm{to\\_Bat}}\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Charge balance constraints : \\[\\begin{flalign*} & Q_k =Q_{k-1} +\\eta^{\\mathrm{to\\_Bat}} \\cdot \\;P_k^{\\mathrm{to\\_Bat}} \\Delta t-\\;P_k^{\\mathrm{from\\_Bat}} \\Delta t\\\\ & Q_0 =Q_{\\mathrm{init}}\\\\ & Q_n =Q_{\\mathrm{final}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Genset constraints : \\[\\begin{flalign*} & P_{k\\;} \\le {0\\ldotp 9P}_{\\mathrm{max}\\;} {\\cdot y}_k & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n\\\\ & P_{k\\;} \\le {0\\ldotp 2P}_{\\mathrm{max}\\;} {\\cdot y}_k\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Battery logical constraints : \\[\\begin{flalign*} & y_k^{\\mathrm{to\\_Bat}} +y_{k\\;}^{\\mathrm{from\\_Bat}} \\le 1 & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n\\\\ & P_k^{\\mathrm{to\\_Bat}} \\le 0\\ldotp 9P_{\\mathrm{max}} {\\cdot y}_k^{\\mathrm{to\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\\\ & P_k^{\\mathrm{from\\_Bat}} \\le 0\\ldotp 9P_{\\mathrm{max}} {\\cdot \\;y}_k^{\\mathrm{from\\_Bat}} & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Fuel consumption : \\[\\begin{flalign*} & {FC}_{k\\;} ={aP}_{k\\;} +b-{fc}_{offset} \\cdot \\left(1-y_k \\right)\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{flalign*}\\] Objective linearization : \\[\\begin{flalign*} & z_k \\ge y_k -y_{k-1} & \\forall\\,\\,\\,\\,\\,\\, k=2,\\dots ,n \\end{flalign*}\\]","title":"Set of problem LP constraints"},{"location":"lp_vars/","text":"Linear programming variables. \u00b6 Linear programing (LP) variables are the variables whose values the optimizer will solve for in each time step. Set of LpVariables: \u00b6 LPvariable Definition Unit Type \\(Q_{\\ bat, k}\\) Battery charge. kWh Continuous \\(P_{k}\\) Power generated by the genset. kW Continuous \\(P_{\\mathrm{load}, k}\\) Power from genset to the load. kW Continuous \\(P_{\\mathrm{to\\_bat}, k}\\) Power from genset to the battery. kW Continuous \\(P_{\\mathrm{from\\_bat}, k}\\) Power from the battery to the load. kW Continuous \\(Y_k\\) Logical variable indicating the state of genset. - Binary \\(Y_{\\mathrm{to\\_bat}, k}\\) Logical charging variable for the battery. - Binary \\(Y_{\\mathrm{from\\_bat}, k}\\) Logical discarging variable for the battery. - Binary \\(Z\\) Aditional cost fuel oil consumption when starting Genset. - Binary \\(FOC\\) Genset fuel oil consumption. g Continuous The index \\(k\\) is in all cases used to the denote a particular time step.","title":"Variables"},{"location":"lp_vars/#linear-programming-variables","text":"Linear programing (LP) variables are the variables whose values the optimizer will solve for in each time step.","title":"Linear programming variables."},{"location":"lp_vars/#set-of-lpvariables","text":"LPvariable Definition Unit Type \\(Q_{\\ bat, k}\\) Battery charge. kWh Continuous \\(P_{k}\\) Power generated by the genset. kW Continuous \\(P_{\\mathrm{load}, k}\\) Power from genset to the load. kW Continuous \\(P_{\\mathrm{to\\_bat}, k}\\) Power from genset to the battery. kW Continuous \\(P_{\\mathrm{from\\_bat}, k}\\) Power from the battery to the load. kW Continuous \\(Y_k\\) Logical variable indicating the state of genset. - Binary \\(Y_{\\mathrm{to\\_bat}, k}\\) Logical charging variable for the battery. - Binary \\(Y_{\\mathrm{from\\_bat}, k}\\) Logical discarging variable for the battery. - Binary \\(Z\\) Aditional cost fuel oil consumption when starting Genset. - Binary \\(FOC\\) Genset fuel oil consumption. g Continuous The index \\(k\\) is in all cases used to the denote a particular time step.","title":"Set of LpVariables:"},{"location":"obj_func/","text":"Optimization objective. \u00b6 Objective function \u00b6 The objective function is the goal behind why we set the problem. In our case the problem is an optimization problem so the the objective functin is an optimization objective. However the Optimization objective is two types either a maximization objective or minimization objective. Since we wish to reduce the energy cost then our optimzatio objective is a minimization one. Problem minimization objective \u00b6 In our case the miminzation objective is that The total fuel consumptions (kg) of the trip which are fuel consumption (as a function of required power output) for the genset including an additional cost for re starting the genset. therefore the Problem minimization objective could be formulated as follow : \\[\\begin{flalign*} \\mathrm{Minimize}\\;\\;\\;\\;\\;\\sum_{k=1}^n {FC}_{k\\;} \\cdot \\frac{\\Delta t}{1000}+K_{\\mathrm{start}}. \\sum_{k=2}^n Z_k \\end{flalign*}\\] given the fuel consumption linear model : \\[\\begin{align} & {FC}_{k\\;} ={aP}_{k\\;} +b-{fc}_{offset} \\cdot \\left(1-y_k \\right)\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{align}\\]","title":"Objective"},{"location":"obj_func/#optimization-objective","text":"","title":"Optimization objective."},{"location":"obj_func/#objective-function","text":"The objective function is the goal behind why we set the problem. In our case the problem is an optimization problem so the the objective functin is an optimization objective. However the Optimization objective is two types either a maximization objective or minimization objective. Since we wish to reduce the energy cost then our optimzatio objective is a minimization one.","title":"Objective function"},{"location":"obj_func/#problem-minimization-objective","text":"In our case the miminzation objective is that The total fuel consumptions (kg) of the trip which are fuel consumption (as a function of required power output) for the genset including an additional cost for re starting the genset. therefore the Problem minimization objective could be formulated as follow : \\[\\begin{flalign*} \\mathrm{Minimize}\\;\\;\\;\\;\\;\\sum_{k=1}^n {FC}_{k\\;} \\cdot \\frac{\\Delta t}{1000}+K_{\\mathrm{start}}. \\sum_{k=2}^n Z_k \\end{flalign*}\\] given the fuel consumption linear model : \\[\\begin{align} & {FC}_{k\\;} ={aP}_{k\\;} +b-{fc}_{offset} \\cdot \\left(1-y_k \\right)\\ & \\forall\\,\\,\\,\\,\\,\\, k=1,\\dots ,n \\end{align}\\]","title":"Problem minimization objective"},{"location":"parameters/","text":"Problem parameters. \u00b6 Optimization parameters \u00b6 The optimization parameters are a set of paramters that have been used along with this optimization problem. These parameters are related to power generation, energy charge and discharge, time, and some additional parameters in a the mathimatical conceptuality of the problem and cost efficiency. The problem results and simulations are based on the values given to these parameters and changing them will trigger different results depending on the physical component of the problem (batterie(s) and genset(s) specifications). Set of parameters: \u00b6 Parameter Definition Unit \\(Q_{\\mathrm{max}}\\) Maximal energy charge stored in the battery. kWh \\(Q_{\\mathrm{init}}\\) Initial energy charge stored in the battery. kWh \\(Q_{\\mathrm{final}}\\) Final charge stored in the battery. kWh \\(P_{\\mathrm{max}\\;}\\) Maximal power that can be generated by the genset. kW \\(P_{\\mathrm{min}\\;}\\) Minimal power that can be generated by the genset kW \\(Max_{FC}\\) Maximal fuel consumption. g \\(\\Delta t\\) Time step in discretization. h \\(t_{\\mathrm{max}\\;}\\) Max time in simulation. h \\(n\\) Number of time steps in simulation. - \\(t\\) Time vector in simulation (dimension(t)=n). h \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(\\eta^{\\mathrm{from\\_Bat}}\\) Efficiency when releasing from the battery. - \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(fc_{\\mathrm{offset}\\;}\\) fuel oil consumption offset. g \\(L\\) Vector of pre-defined load profile (must be of same length as time vector). kWh","title":"Parameters"},{"location":"parameters/#problem-parameters","text":"","title":"Problem parameters."},{"location":"parameters/#optimization-parameters","text":"The optimization parameters are a set of paramters that have been used along with this optimization problem. These parameters are related to power generation, energy charge and discharge, time, and some additional parameters in a the mathimatical conceptuality of the problem and cost efficiency. The problem results and simulations are based on the values given to these parameters and changing them will trigger different results depending on the physical component of the problem (batterie(s) and genset(s) specifications).","title":"Optimization parameters"},{"location":"parameters/#set-of-parameters","text":"Parameter Definition Unit \\(Q_{\\mathrm{max}}\\) Maximal energy charge stored in the battery. kWh \\(Q_{\\mathrm{init}}\\) Initial energy charge stored in the battery. kWh \\(Q_{\\mathrm{final}}\\) Final charge stored in the battery. kWh \\(P_{\\mathrm{max}\\;}\\) Maximal power that can be generated by the genset. kW \\(P_{\\mathrm{min}\\;}\\) Minimal power that can be generated by the genset kW \\(Max_{FC}\\) Maximal fuel consumption. g \\(\\Delta t\\) Time step in discretization. h \\(t_{\\mathrm{max}\\;}\\) Max time in simulation. h \\(n\\) Number of time steps in simulation. - \\(t\\) Time vector in simulation (dimension(t)=n). h \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(\\eta^{\\mathrm{from\\_Bat}}\\) Efficiency when releasing from the battery. - \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(\\eta^{\\mathrm{to\\_Bat}}\\) Efficiency when charging the battery. - \\(fc_{\\mathrm{offset}\\;}\\) fuel oil consumption offset. g \\(L\\) Vector of pre-defined load profile (must be of same length as time vector). kWh","title":"Set of parameters:"},{"location":"prblm_size/","text":"Problem size. \u00b6 comuputation cost is the most implicaated factor when it comes to designing optimization based software solutions as it can affect the speed for processing information and hence delaying outputs. Therefore, We need to know the problem size in order to see if the problem is computationaly cost effective or not, our problem size is mainly dependant on the size of the load window time frame (i.e., steps \\({n}\\) ), the number of LP variables, the number of gensets \\({m}\\) (we use 1 genset in our case) and the numbere of problem constraints. \\[\\begin{flalign*} \\begin{cases} - Continuous &: & 6.n.m \\\\ - Binary &: & 4.n.m \\\\ - Constraints &: & 9.n.m \\end{cases} \\end{flalign*}\\]","title":"Problem size"},{"location":"prblm_size/#problem-size","text":"comuputation cost is the most implicaated factor when it comes to designing optimization based software solutions as it can affect the speed for processing information and hence delaying outputs. Therefore, We need to know the problem size in order to see if the problem is computationaly cost effective or not, our problem size is mainly dependant on the size of the load window time frame (i.e., steps \\({n}\\) ), the number of LP variables, the number of gensets \\({m}\\) (we use 1 genset in our case) and the numbere of problem constraints. \\[\\begin{flalign*} \\begin{cases} - Continuous &: & 6.n.m \\\\ - Binary &: & 4.n.m \\\\ - Constraints &: & 9.n.m \\end{cases} \\end{flalign*}\\]","title":"Problem size."},{"location":"user_quick_guide/","text":"User quick guide. \u00b6 Optimization variable. \u00b6 The optimization variable is the variable that will host problem solving results, it is created via the command LpProblem() . Inside the parenthesis we can assign a name for the optimization problem beeing solved as well as defining which type the problem is. whether is a maximization or minmization ('LpMaximize' for maximization or 'LpMinimize' for minimization problem). In our case it is Minimization problem, therfore to create our optimization problem variable we can do something like : Optim = LpProblem('Energy_Opt',LpMinimize) \\(\\newline\\) Decision variables. \u00b6 LpVariable(). \u00b6 Creating decsion variables is easy as using the command LpVariable() , inside the parenthesis we can give it a name, and setting the variable min and max bounds admissible for that paticular decision variable. note : it's important to set carfully the bounds otherwise it can easily leads to an infeasable problem within the solving process. LpVariable.dicts(). \u00b6 In our case, each decision variable is descritisized depending to load window vector steps, they will contain as much points as the number of steps : dem(LpVaraible) = dem(V_steps). Based on this approach it's convinent to set our decision variable points as key-values pair in a dictionnary. To create a dictionary decision variable we use the command LpVariable.dicts() , inside the parenthesise we can define the LpVariable lower and upper bounds type using LowBound and upBound , the cat argument can be used to define the LpVariable type as well. Our 10 decision varaibles then are set up as following: Q_bat = LpVariable.dicts(\"Q_bat\", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous) # Battery charge at time step k. P_From_bat = LpVariable.dicts(\"P_From_bat\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power transfered from the battery to the load. P = LpVariable.dicts(\"P_A\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power generated by the Genset A. P_load = LpVariable.dicts(\"P_A_load\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k. Z = LpVariable.dicts(\"Z\", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j. FOC = LpVariable.dicts(\"FC_A\", V_steps, lowBound=0, upBound= maxFC, cat=LpContinuous) # Specific fuel oil consumption. P_to_bat = LpVariable.dicts(\"P_A_to_bat\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) Y_to_bat = LpVariable.dicts(\"Y_to_bat\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. Y_from_bat = LpVariable.dicts(\"Y_from_bat\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k. Y = LpVariable.dicts(\"Y\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0. \\(\\newline\\) Setting up the objective function. \u00b6 To set up the objective function of the problem, the lpSum function is used along side with the optimization variable created Optim , so it can be formulated as : Optim += lpSum (Expression) . the += operator is used to update the Optim variable after each solving itteration. Note: the Objective function must be included first before the constraints are made, outherwise, it will just be interpreted as a constraint by the solver. In our case the, the objective is to minimize the Genset fuel oil consumption, therefore it is expressed as: Optim += lpSum (FC + L_added_cost), \"objective function Minimization fuel oil consumption\" \\(\\newline\\) Setting up problem constraints. \u00b6 Constraints are expressed using the same command used for setting up the objective function, that's why the objective fucntion should be included first. The set of constraints for our problem are expressed as follow: for k in V_steps: # Fuel oil consumption constraint. Optim += FOC[k] == P[k]*a_j + b_j - fc_j_offset*(1-Y[k]) # Load requirements constraints Optim += P_load[k] + eff_from_bat*P_From_bat[k] == L[k] Optim += P_load[k] + P_to_bat[k] == P[k] # Genset logical constraints. Optim += P[k] <= 0.9 * P_max * Y[k] Optim += P[k] >= 0.2 * P_max * Y[k] # Battery charging logical constraints. Optim += P_to_bat[k] <= 0.9 * P_max * Y_to_bat[k] Optim += P_From_bat[k] <= 0.9 * P_max * Y_from_bat[k] Optim += Y_to_bat[k] + Y_from_bat[k] <= 1 # Charge balance logical constraints. if k == V_steps[0] : Optim += Q_bat[k] == Q_0 + eff_to_bat*P_to_bat[k]*dt - P_From_bat[k]*dt else : Optim += Q_bat[k] == Q_bat[k-1] + eff_to_bat*P_to_bat[k]*dt - P_From_bat[k]*dt # Additional starting costs constraint. for k in range(V_steps[0], V_steps[-1]): Optim += Z[k] >= Y[k + 1] - Y[k] # Charge balance at the Final time step. Optim += Q_bat[V_steps[-1]] == Q_final \\(\\newline\\) Solving the problem. \u00b6 After constructing the problem with the different steps, now we can solve it using the command, and store the results in a variable. something like : result = Optim.solve() Note that inside the parenthesis you can specify the solver you want to use, if nothing is specified then the defaut solver is used which is CBC solver. However, in our case we are using the Gurobi solver, therfore, we can call it as follow : result = Optim.solve(GUROBI())","title":"User quick guide"},{"location":"user_quick_guide/#user-quick-guide","text":"","title":"User quick guide."},{"location":"user_quick_guide/#optimization-variable","text":"The optimization variable is the variable that will host problem solving results, it is created via the command LpProblem() . Inside the parenthesis we can assign a name for the optimization problem beeing solved as well as defining which type the problem is. whether is a maximization or minmization ('LpMaximize' for maximization or 'LpMinimize' for minimization problem). In our case it is Minimization problem, therfore to create our optimization problem variable we can do something like : Optim = LpProblem('Energy_Opt',LpMinimize) \\(\\newline\\)","title":"Optimization variable."},{"location":"user_quick_guide/#decision-variables","text":"","title":"Decision variables."},{"location":"user_quick_guide/#lpvariable","text":"Creating decsion variables is easy as using the command LpVariable() , inside the parenthesis we can give it a name, and setting the variable min and max bounds admissible for that paticular decision variable. note : it's important to set carfully the bounds otherwise it can easily leads to an infeasable problem within the solving process.","title":"LpVariable()."},{"location":"user_quick_guide/#lpvariabledicts","text":"In our case, each decision variable is descritisized depending to load window vector steps, they will contain as much points as the number of steps : dem(LpVaraible) = dem(V_steps). Based on this approach it's convinent to set our decision variable points as key-values pair in a dictionnary. To create a dictionary decision variable we use the command LpVariable.dicts() , inside the parenthesise we can define the LpVariable lower and upper bounds type using LowBound and upBound , the cat argument can be used to define the LpVariable type as well. Our 10 decision varaibles then are set up as following: Q_bat = LpVariable.dicts(\"Q_bat\", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous) # Battery charge at time step k. P_From_bat = LpVariable.dicts(\"P_From_bat\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power transfered from the battery to the load. P = LpVariable.dicts(\"P_A\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power generated by the Genset A. P_load = LpVariable.dicts(\"P_A_load\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k. Z = LpVariable.dicts(\"Z\", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j. FOC = LpVariable.dicts(\"FC_A\", V_steps, lowBound=0, upBound= maxFC, cat=LpContinuous) # Specific fuel oil consumption. P_to_bat = LpVariable.dicts(\"P_A_to_bat\", V_steps, lowBound=0, upBound=0.9*P_A_max, cat=LpContinuous) Y_to_bat = LpVariable.dicts(\"Y_to_bat\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. Y_from_bat = LpVariable.dicts(\"Y_from_bat\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k. Y = LpVariable.dicts(\"Y\", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0. \\(\\newline\\)","title":"LpVariable.dicts()."},{"location":"user_quick_guide/#setting-up-the-objective-function","text":"To set up the objective function of the problem, the lpSum function is used along side with the optimization variable created Optim , so it can be formulated as : Optim += lpSum (Expression) . the += operator is used to update the Optim variable after each solving itteration. Note: the Objective function must be included first before the constraints are made, outherwise, it will just be interpreted as a constraint by the solver. In our case the, the objective is to minimize the Genset fuel oil consumption, therefore it is expressed as: Optim += lpSum (FC + L_added_cost), \"objective function Minimization fuel oil consumption\" \\(\\newline\\)","title":"Setting up the objective function."},{"location":"user_quick_guide/#setting-up-problem-constraints","text":"Constraints are expressed using the same command used for setting up the objective function, that's why the objective fucntion should be included first. The set of constraints for our problem are expressed as follow: for k in V_steps: # Fuel oil consumption constraint. Optim += FOC[k] == P[k]*a_j + b_j - fc_j_offset*(1-Y[k]) # Load requirements constraints Optim += P_load[k] + eff_from_bat*P_From_bat[k] == L[k] Optim += P_load[k] + P_to_bat[k] == P[k] # Genset logical constraints. Optim += P[k] <= 0.9 * P_max * Y[k] Optim += P[k] >= 0.2 * P_max * Y[k] # Battery charging logical constraints. Optim += P_to_bat[k] <= 0.9 * P_max * Y_to_bat[k] Optim += P_From_bat[k] <= 0.9 * P_max * Y_from_bat[k] Optim += Y_to_bat[k] + Y_from_bat[k] <= 1 # Charge balance logical constraints. if k == V_steps[0] : Optim += Q_bat[k] == Q_0 + eff_to_bat*P_to_bat[k]*dt - P_From_bat[k]*dt else : Optim += Q_bat[k] == Q_bat[k-1] + eff_to_bat*P_to_bat[k]*dt - P_From_bat[k]*dt # Additional starting costs constraint. for k in range(V_steps[0], V_steps[-1]): Optim += Z[k] >= Y[k + 1] - Y[k] # Charge balance at the Final time step. Optim += Q_bat[V_steps[-1]] == Q_final \\(\\newline\\)","title":"Setting up problem constraints."},{"location":"user_quick_guide/#solving-the-problem","text":"After constructing the problem with the different steps, now we can solve it using the command, and store the results in a variable. something like : result = Optim.solve() Note that inside the parenthesis you can specify the solver you want to use, if nothing is specified then the defaut solver is used which is CBC solver. However, in our case we are using the Gurobi solver, therfore, we can call it as follow : result = Optim.solve(GUROBI())","title":"Solving the problem."}]}